import { Probot } from "probot";

const BACKEND_URL = process.env.BACKEND_URL || "http://localhost:8000";

interface Violation {
  rule_id: string;
  rule_name: string;
  severity: string;
  message: string;
  file_path: string;
  line_number: number;
  line_content: string;
  suggested_fix?: string;
  cwe_id?: string;
  owasp_category?: string;
  is_copilot_generated: boolean;
}

interface AnalysisResponse {
  success: boolean;
  violations: Violation[];
  violation_count: number;
  critical_count: number;
  high_count: number;
  scan_id: string;
}

async function fetchPRDiff(context: any, owner: string, repo: string, prNumber: number): Promise<{ [key: string]: string }> {
  const files = await context.octokit.pulls.listFiles({
    owner,
    repo,
    pull_number: prNumber,
  });

  const diffs: { [key: string]: string } = {};

  for (const file of files.data) {
    if (file.patch) {
      diffs[file.filename] = file.patch;
    }
  }

  return diffs;
}

async function analyzePR(context: any, owner: string, repo: string, prNumber: number, commitHash: string) {
  try {
    // Fetch PR diff
    const files = await fetchPRDiff(context, owner, repo, prNumber);

    if (Object.keys(files).length === 0) {
      return;
    }

    // Call backend analysis
    const response = await fetch(`${BACKEND_URL}/api/analyze`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        repo_name: `${owner}/${repo}`,
        pr_number: prNumber,
        commit_hash: commitHash,
        files: files,
        copilot_generated_files: [], // Can be enhanced to detect Copilot comments
      }),
    });

    if (!response.ok) {
      console.error(`Backend analysis failed: ${response.statusText}`);
      return;
    }

    const result: AnalysisResponse = await response.json();

    if (!result.success || result.violations.length === 0) {
      // Post success comment if no violations
      const successComment = `‚úÖ **Guardrails Scan Passed**\n\nNo security violations detected in this PR.`;
      await context.octokit.issues.createComment(
        context.issue({
          body: successComment,
        })
      );
      return;
    }

    // Format violations by severity
    let commentBody = `## üîç Guardrails Security Scan\n\n`;
    commentBody += `**Scan ID:** \`${result.scan_id}\`\n\n`;

    // Summary
    commentBody += `### Summary\n`;
    commentBody += `- **Total Issues:** ${result.violation_count}\n`;
    if (result.critical_count > 0) commentBody += `- üî¥ **Critical:** ${result.critical_count}\n`;
    if (result.high_count > 0) commentBody += `- üü† **High:** ${result.high_count}\n`;
    commentBody += `\n`;

    // Group by severity
    const bySeverity: { [key: string]: Violation[] } = {};
    for (const violation of result.violations) {
      if (!bySeverity[violation.severity]) {
        bySeverity[violation.severity] = [];
      }
      bySeverity[violation.severity].push(violation);
    }

    const severityOrder = ["critical", "high", "medium", "low", "info"];

    for (const severity of severityOrder) {
      if (!bySeverity[severity] || bySeverity[severity].length === 0) {
        continue;
      }

      const icon = {
        critical: "üî¥",
        high: "üü†",
        medium: "üü°",
        low: "üîµ",
        info: "‚ÑπÔ∏è",
      }[severity] || "‚Ä¢";

      commentBody += `### ${icon} ${severity.toUpperCase()} Issues\n\n`;

      for (const violation of bySeverity[severity]) {
        commentBody += `<details>\n`;
        commentBody += `<summary><b>${violation.rule_name}</b> (${violation.rule_id}) in <code>${violation.file_path}:${violation.line_number}</code></summary>\n\n`;
        commentBody += `**Issue:** ${violation.message}\n\n`;
        commentBody += `**Code:**\n\`\`\`\n${violation.line_content}\n\`\`\`\n\n`;

        if (violation.suggested_fix) {
          commentBody += `**Suggested Fix:**\n\`\`\`\n${violation.suggested_fix}\n\`\`\`\n\n`;
        }

        if (violation.cwe_id) {
          commentBody += `**CWE:** [${violation.cwe_id}](https://cwe.mitre.org/data/definitions/${violation.cwe_id.split("-")[1]}.html)\n`;
        }

        if (violation.owasp_category) {
          commentBody += `**OWASP:** ${violation.owasp_category}\n`;
        }

        if (violation.is_copilot_generated) {
          commentBody += `\n‚ö†Ô∏è **Note:** This code was generated by GitHub Copilot. Extra caution recommended.\n`;
        }

        commentBody += `\n</details>\n\n`;
      }
    }

    commentBody += `---\n`;
    commentBody += `**Policy:** Advisory Mode - Review these issues before merge.\n`;
    commentBody += `*Generated by Guardrails Security Scanner*\n`;

    // Post comment
    await context.octokit.issues.createComment(
      context.issue({
        body: commentBody,
      })
    );
  } catch (error) {
    console.error("Error during PR analysis:", error);
    // Post error comment
    await context.octokit.issues.createComment(
      context.issue({
        body: `‚ö†Ô∏è **Guardrails Scan Error**\n\nFailed to analyze this PR. Please check the logs.\n\nError: ${error instanceof Error ? error.message : "Unknown error"}`,
      })
    );
  }
}

export default (app: Probot) => {
  app.on("pull_request", async (context) => {
    const pullRequest = context.payload.pull_request;
    const action = context.payload.action;

    // Only run on PR open or synchronize (new commits pushed)
    if (action !== "opened" && action !== "synchronize") {
      return;
    }

    const owner = pullRequest.base.repo.owner.login;
    const repo = pullRequest.base.repo.name;
    const prNumber = pullRequest.number;
    const commitHash = pullRequest.head.sha;

    await analyzePR(context, owner, repo, prNumber, commitHash);
  });

  // For more information on building apps:
  // https://probot.github.io/docs/

  // To get your app running against GitHub, see:
  // https://probot.github.io/docs/development/
};
